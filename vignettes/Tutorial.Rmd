---
title: "MarkRank Tutorial"
author: "Ling-Yun Wu"
date: "`r Sys.Date()`"
output: 
  pdf_document:
    latex_engine: xelatex
    number_sections: yes
    toc: yes
vignette: >
  %\VignetteIndexEntry{MarkRank Tutorial}
  %\VignetteEngine{knitr::rmarkdown}
---

# MarkRank algorithm

MarkRank is a novel proposed network-based model for identifying the cooperative biomarkers. MarkRank uses the gene cooperation network to explicitly evaluate the gene cooperative effects. MarkRank suggests that explicit modeling of gene cooperative effects can greatly improve biomarker identification for complex diseases, especially for diseases with high heterogeneity. This tutorial could help the user to execute the markrank function compiled in the Corbi package.

We imported the Corbi and other required packages:
```{r}
rm(list=ls(all=TRUE))
library(Corbi)
library(Matrix)
options(scipen=0)
```

# MarkRank example

The inputs of markrank function is an expression dataset of known label (disease and normal) samples and an adjacent matrix of biological network. We use the simulation datasets to show the usage of markrank function.

## Generate the model inputs

First, we load in a small network using another function read_net compiled in Corbi.
```{r}
sub_info <- read_net("network.txt")
```

This network contains 100 genes. Then we set the number of preset differential expression nodes.
```{r}
size <- 10
```

We randomly extract a connected subnetwork with the preset size from the loaded network. Here we use the function search_net to implement.
```{r}
source("search_net.R")
preset  <- search_net(sub_info, node_size = size, ori_name = TRUE)
de_list <- as.character(unique(as.vector(preset)))
```

The preset differentially expression genes are:
```{r}
de_list
```

Now we simulate the expression matrix. The sample number is set as
```{r}
sam_num <- 50	
```

The number of disease samples and normal samples are equal.
```{r}
half <- 25
```

The code of simulating the expression dataset is as follows. We up-regulated the expression values of preset differentially expression gene set. The detailed description of this process can be found in the Supplementary Materials in our manuscript.
```{r}
library(matrixcalc)
library(MASS)
l <- sub_info$size
p <- length(de_list)
dataset <- matrix(0, sam_num, l, dimnames = list(paste("sample", 1:sam_num, sep=""), sub_info$node))
vars  <- 1
sigma <- matrix(0)
while(!is.positive.definite(sigma)){										
  vars  <- vars + 1 
  sigma <- as.matrix(as(sub_info$matrix,'dgCMatrix'))									
  sigma[which(sigma == 1)] <- rnorm(length(which(sigma == 1)), 4, 1)		
  sigma[which(sigma == 0)] <- rnorm(length(which(sigma == 0)), 2, 1)		
  diag(sigma) <- rnorm(l, vars, 1)
  sigma <- (sigma + t(sigma))/2
}
multi_mean <- rnorm(l, 5, 1)
dataset <- mvrnorm(sam_num, multi_mean, sigma)								
dataset[1:half, de_list] <- dataset[1:half, de_list] * rnorm(half*p, 2, 0.1)
```

The final simulated microarray expression matrix contains 50 samples and 100 genes. The number of preset marker genes is 10.
```{r}
dim(dataset)
```  

The sample label is
```{r}
label <- c(rep(0, half), rep(1, half))
```  

The adjacent matrix of the network is
```{r}
adj_matrix <- as.matrix(sub_info$matrix)
adj_matrix <- adj_matrix[colnames(dataset), colnames(dataset)]
adj_matrix <- adj_matrix + t(adj_matrix)
``` 

## Run the markrank function

With the above simulated variables as model inputs, we now execute the markrank function to test whether MarkRank could prioritize the preset genes. We use the default parameter combination as alpha=0.8 and lambda=0.2 to run the markrank.
```{r}
time1 <- system.time(
  result1 <- markrank(dataset, label, adj_matrix, alpha=0.8, lambda=0.2, trace=TRUE)
  )
``` 

The output variable result contains the following model outputs:
```{r}
names(result1)
``` 

The scores of top 10 markrank genes are:
```{r}
s1 <- sort(result1$score, decreasing=TRUE)
s1[1:10]
``` 

The scores of pre-set differential expression genes are:
```{r}
result1$score[de_list]	
``` 

The false discovery genes are:
```{r}
setdiff(names(s1[1:10]), de_list)									
``` 

The iteration steps in the random walk iteration is
```{r}
result1$steps									
```

The user could find the input parameters by using the following code:
```{r}
result1$initial_pars								
```


# Tune the model parameters
The computation of gene cooperation network (G2) is separated from the random walk iteration. The computation result of G2 is stored in
```{r}
NET2 <- result1$NET2			
``` 

Using the parameter Given_NET2, we could tune the parameters without the repeated computation of G2 For example, we use the alpha=0.8 and lambda=0.5 to compute the related result:
```{r}
time2 <- system.time(
  result2 <- markrank(dataset, label, adj_matrix, lambda=0.5, trace=FALSE, Given_NET2=NET2)
  )
``` 

The running time of two models is:
```{r}
time1
time2
``` 

The running time of result2 is far less than result1, because the result2 just contains the random walk iteration step. Now the new scores of top 10 markrank genes are:
```{r}
s2 <- sort(result2$score, decreasing=TRUE)
s2[1:10]
``` 

The scores of pre-set differential expression genes are:
```{r}
result2$score[de_list]	
``` 

The false discovery genes are:
```{r}
setdiff(names(s2[1:10]), de_list)									
``` 

# The simplified version for G2 construction

By using the input parameter d, markrank could reduce the computation time on the construction of G2. Only the gene pairs whose shortest distances in the PPI network are less than d participate in G2 construction. For example, we could run
```{r}
time3 <- system.time(
  result3 <- markrank(dataset, label, adj_matrix, trace=F, d=2)
  )
``` 

The running time of two models is:
```{r}
time1
time3
```

In this situation, the distance information of each gene pair can be found in output variable dis. For example, the distance matrix of gene 1 to 10 is:
```{r}
result3$dis[1:10,1:10]
```

The user should balance the calculation depth with computation time to achieve a acceptable result.
